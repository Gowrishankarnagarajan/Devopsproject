# .github/workflows/Apply.yml
name: Terraform Provision & Deploy Container Apps

on:
  push:
    branches: [main]

permissions:
  contents: read
  id-token: write # Required for Azure Login with OIDC

jobs:
  provision-infra:
    name: Provision Core Infrastructure
    runs-on: ubuntu-latest

    outputs:
      acr_login_server: ${{ steps.acr_output.outputs.acr_login_server }}
      log_analytics_workspace_id: ${{ steps.logs_output.outputs.log_analytics_workspace_id }}
      resource_group_name: ${{ steps.rg_output.outputs.resource_group_name }}
      location: ${{ steps.location_output.outputs.location }}
      servicebus_namespace_name: ${{ steps.servicebus_output.outputs.servicebus_namespace_name }}
      servicebus_connection_string: ${{ steps.servicebus_output.outputs.servicebus_connection_string }}
      cosmosdb_mongodb_connection_string: ${{ steps.cosmosdb_mongodb_output.outputs.cosmosdb_mongodb_connection_string }}
      cosmosdb_workflow_connection_string: ${{ steps.cosmosdb_workflow_output.outputs.cosmosdb_workflow_connection_string }}
      redis_connection_string: ${{ steps.redis_output.outputs.redis_connection_string }}
      application_insights_connection_string: ${{ steps.appinsights_output.outputs.application_insights_connection_string }}
      key_vault_uri: ${{ steps.keyvault_output.outputs.key_vault_uri }}
      key_vault_id: ${{ steps.keyvault_id_output.outputs.key_vault_id }} # Added Key Vault ID output

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.2 # Pinning Terraform version as suggested by Copilot

      - name: Terraform Init (Infra)
        run: terraform -chdir=terraform/infra init

      - name: Terraform Apply (Infra)
        run: terraform -chdir=terraform/infra apply -auto-approve

      # --- Output Retrieval Steps for Infra ---
      - name: Get ACR Login Server
        id: acr_output
        run: |
          set -euo pipefail
          FULL_COMMAND_OUTPUT=$(terraform -chdir=terraform/infra output -raw acr_login_server 2>&1)
          echo "::debug::FULL_COMMAND_OUTPUT captured: '$FULL_COMMAND_OUTPUT'"
          ACR_NAME=$(echo "$FULL_COMMAND_OUTPUT" | grep -oE '[a-zA-Z0-9.-]+\.azurecr\.io' | head -n 1)
          echo "::debug::ACR_NAME extracted after regex: '$ACR_NAME'"
          printf "acr_login_server=%s\n" "$ACR_NAME" >> "$GITHUB_OUTPUT"
          echo "::debug::Content written to GITHUB_OUTPUT file:"
          cat "$GITHUB_OUTPUT"

      - name: Debug ACR Login Server
        run: echo "::notice::ACR is ${{ steps.acr_output.outputs.acr_login_server }}"

      - name: Get Log Analytics Workspace ID
        id: logs_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Log Analytics Workspace ID
          # Removed the grep to ensure the full resource ID is captured.
          RAW_LOG_ID_OUTPUT=$(terraform -chdir=terraform/infra output -raw log_analytics_workspace_id 2>&1)
          echo "::debug::Raw Log Analytics Workspace ID Output: '$RAW_LOG_ID_OUTPUT'"
          # LOG_ID=$(echo "$RAW_LOG_ID_OUTPUT" | grep -oE '[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}' | head -n 1) # REMOVED THIS LINE
          LOG_ID=$(echo "$RAW_LOG_ID_OUTPUT" | head -n 1 | tr -d '\r') # Capture full string and remove newlines
          echo "::debug::Extracted Log Analytics Workspace ID: '$LOG_ID'"
          printf "log_analytics_workspace_id=%s\n" "$LOG_ID" >> "$GITHUB_OUTPUT"

      - name: Get Resource Group Name
        id: rg_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Resource Group Name
          RAW_RG_NAME_OUTPUT=$(terraform -chdir=terraform/infra output -raw resource_group_name 2>&1)
          echo "::debug::Raw Resource Group Name Output: '$RAW_RG_NAME_OUTPUT'"
          RG_NAME=$(echo "$RAW_RG_NAME_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Resource Group Name: '$RG_NAME'"
          printf "resource_group_name=%s\n" "$RG_NAME" >> "$GITHUB_OUTPUT"

      - name: Get Location
        id: location_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Location
          RAW_LOCATION_OUTPUT=$(terraform -chdir=terraform/infra output -raw location 2>&1)
          echo "::debug::Raw Location Output: '$RAW_LOCATION_OUTPUT'"
          LOCATION=$(echo "$RAW_LOCATION_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Location: '$LOCATION'"
          printf "location=%s\n" "$LOCATION" >> "$GITHUB_OUTPUT"

      - name: Get Service Bus Namespace Name & Connection String
        id: servicebus_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for namespace name
          RAW_NAMESPACE_OUTPUT=$(terraform -chdir=terraform/infra output -raw servicebus_namespace_name 2>&1)
          echo "::debug::Raw Service Bus Namespace Name Output: '$RAW_NAMESPACE_OUTPUT'"
          NAMESPACE_NAME=$(echo "$RAW_NAMESPACE_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Service Bus Namespace Name: '$NAMESPACE_NAME'"

          # Debugging: Print the raw output for connection string
          RAW_CONNECTION_STRING_OUTPUT=$(terraform -chdir=terraform/infra output -raw servicebus_connection_string 2>&1)
          echo "::debug::Raw Service Bus Connection String Output: '$RAW_CONNECTION_STRING_OUTPUT'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Service Bus Connection String: '$CONNECTION_STRING'"

          printf "servicebus_namespace_name=%s\n" "$NAMESPACE_NAME" >> "$GITHUB_OUTPUT"
          printf "servicebus_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Cosmos DB MongoDB Connection String
        id: cosmosdb_mongodb_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for MongoDB connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw cosmosdb_mongodb_connection_string 2>&1)
          echo "::debug::Raw Cosmos DB MongoDB Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Cosmos DB MongoDB Connection String: '$CONNECTION_STRING'"
          printf "cosmosdb_mongodb_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Cosmos DB Workflow Connection String
        id: cosmosdb_workflow_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Workflow connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw cosmosdb_workflow_connection_string 2>&1)
          echo "::debug::Raw Cosmos DB Workflow Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Cosmos DB Workflow Connection String: '$CONNECTION_STRING'"
          printf "cosmosdb_workflow_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Redis Cache Connection String
        id: redis_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Redis connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw redis_connection_string 2>&1)
          echo "::debug::Raw Redis Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Redis Connection String: '$CONNECTION_STRING'"
          printf "redis_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Application Insights Connection String
        id: appinsights_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Application Insights connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw application_insights_connection_string 2>&1)
          echo "::debug::Raw Application Insights Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Application Insights Connection String: '$CONNECTION_STRING'"
          printf "application_insights_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Key Vault URI
        id: keyvault_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Key Vault URI
          RAW_KEY_VAULT_URI=$(terraform -chdir=terraform/infra output -raw key_vault_uri 2>&1)
          echo "::debug::Raw Key Vault URI Output: '$RAW_KEY_VAULT_URI'"
          KEY_VAULT_URI=$(echo "$RAW_KEY_VAULT_URI" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Key Vault URI: '$KEY_VAULT_URI'"
          printf "key_vault_uri=%s\n" "$KEY_VAULT_URI" >> "$GITHUB_OUTPUT"

      - name: Get Key Vault ID
        id: keyvault_id_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Key Vault ID
          RAW_KEY_VAULT_ID=$(terraform -chdir=terraform/infra output -raw key_vault_id 2>&1)
          echo "::debug::Raw Key Vault ID Output: '$RAW_KEY_VAULT_ID'"
          KEY_VAULT_ID=$(echo "$RAW_KEY_VAULT_ID" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Key Vault ID: '$KEY_VAULT_ID'"
          printf "key_vault_id=%s\n" "$KEY_VAULT_ID" >> "$GITHUB_OUTPUT"

  build-and-push-images:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: provision-infra

    outputs:
      ingestion_image: ${{ steps.push_ingestion.outputs.image_name }}
      workflow_image: ${{ steps.push_workflow.outputs.image_name }}
      package_image: ${{ steps.push_package.outputs.image_name }}
      drone_scheduler_image: ${{ steps.push_drone_scheduler.outputs.image_name }}
      delivery_image: ${{ steps.push_delivery.outputs.image_name }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set ACR Variable
        # Simplified setting of ACR_LOGIN_SERVER into an environment variable
        run: echo "ACR_LOGIN_SERVER=${{ needs.provision-infra.outputs.acr_login_server }}" >> "$GITHUB_ENV"

      - name: Docker Login to ACR
        run: |
          set -euo pipefail
          ACR_NAME=$(echo "$ACR_LOGIN_SERVER" | cut -d. -f1)
          az acr login --name "$ACR_NAME"

      # --- Build & Push Steps for Each Microservice ---
      - name: Build & Push Ingestion Image
        id: push_ingestion
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/ingestion/:"
          ls -R ./sourcecode/ingestion/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially

          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/ingestion:latest"
          if [ ! -f "./sourcecode/ingestion/Dockerfile" ]; then
            echo "::error::Dockerfile not found for ingestion at: ./sourcecode/ingestion/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/ingestion/Dockerfile ./sourcecode/ingestion
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Workflow Image
        id: push_workflow
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/workflow/:"
          ls -R ./sourcecode/workflow/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially

          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/workflow:latest"
          if [ ! -f "./sourcecode/workflow/Dockerfile" ]; then
            echo "::error::Dockerfile not found for workflow at: ./sourcecode/workflow/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/workflow/Dockerfile ./sourcecode/workflow
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Package Image
        id: push_package
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/package/:"
          ls -R ./sourcecode/package/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially

          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/package:latest"
          if [ ! -f "./sourcecode/package/Dockerfile" ]; then
            echo "::error::Dockerfile not found for package at: ./sourcecode/package/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/package/Dockerfile ./sourcecode/package
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Drone Scheduler Image
        id: push_drone_scheduler
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/drone-scheduler/:"
          ls -R ./sourcecode/drone-scheduler/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially

          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/drone-scheduler:latest"
          if [ ! -f "./sourcecode/drone-scheduler/Dockerfile" ]; then
            echo "::error::Dockerfile not found for drone-scheduler at: ./sourcecode/drone-scheduler/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/drone-scheduler/Dockerfile ./sourcecode/drone-scheduler
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Delivery Image
        id: push_delivery
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/delivery/:"
          ls -R ./sourcecode/delivery/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially

          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/delivery:latest"
          if [ ! -f "./sourcecode/delivery/Dockerfile" ]; then
            echo "::error::Dockerfile not found for delivery at: ./sourcecode/delivery/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/delivery/Dockerfile ./sourcecode/delivery
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
      # --- End Build & Push Steps ---

  deploy-apps:
    name: Deploy Container Apps
    runs-on: ubuntu-latest
    needs: [provision-infra, build-and-push-images]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.2 # Pinning Terraform version

      - name: Terraform Init (Apps)
        run: terraform -chdir=terraform/apps init

      - name: Set Resource Group Prefix for Apps
        id: set_rg_prefix
        run: |
          set -euo pipefail
          # Derive the resource_group_name_prefix from the provisioned resource_group_name
          # Ensure no carriage returns interfere with sed.
          RG_NAME=$(echo "${{ needs.provision-infra.outputs.resource_group_name }}" | tr -d '\r')
          RG_NAME_PREFIX=$(echo "$RG_NAME" | sed -E 's/^aca-rg-//')
          printf "resource_group_name_prefix=%s\n" "$RG_NAME_PREFIX" >> "$GITHUB_OUTPUT"
          echo "::debug::resource_group_name_prefix set to: $RG_NAME_PREFIX"

      - name: Terraform Apply (Apps)
        run: |
          set -euo pipefail # Kept for robustness

          # Capture outputs from previous jobs into shell variables
          LOCATION="${{ needs.provision-infra.outputs.location }}"
          RESOURCE_GROUP_NAME="${{ needs.provision-infra.outputs.resource_group_name }}"
          LOG_ANALYTICS_WORKSPACE_ID="${{ needs.provision-infra.outputs.log_analytics_workspace_id }}"
          ACR_LOGIN_SERVER="${{ needs.provision-infra.outputs.acr_login_server }}"
          SERVICEBUS_NAMESPACE_NAME="${{ needs.provision-infra.outputs.servicebus_namespace_name }}"
          SERVICEBUS_CONNECTION_STRING="${{ needs.provision-infra.outputs.servicebus_connection_string }}"
          COSMOSDB_MONGODB_CONNECTION_STRING="${{ needs.provision-infra.outputs.cosmosdb_mongodb_connection_string }}"
          COSMOSDB_WORKFLOW_CONNECTION_STRING="${{ needs.provision-infra.outputs.cosmosdb_workflow_connection_string }}"
          REDIS_CONNECTION_STRING="${{ needs.provision-infra.outputs.redis_connection_string }}"
          APPLICATION_INSIGHTS_CONNECTION_STRING="${{ needs.provision-infra.outputs.application_insights_connection_string }}"
          KEY_VAULT_URI="${{ needs.provision-infra.outputs.key_vault_uri }}"
          KEY_VAULT_ID="${{ needs.provision-infra.outputs.key_vault_id }}"
          INGESTION_IMAGE="${{ needs.build-and-push-images.outputs.ingestion_image }}"
          WORKFLOW_IMAGE="${{ needs.build-and-push-images.outputs.workflow_image }}"
          PACKAGE_IMAGE="${{ needs.build-and-push-images.outputs.package_image }}"
          DRONE_SCHEDULER_IMAGE="${{ needs.build-and-push-images.outputs.drone_scheduler_image }}"
          DELIVERY_IMAGE="${{ needs.build-and-push-images.outputs.delivery_image }}"

          # Get the resource_group_name_prefix from its own step output
          RESOURCE_GROUP_NAME_PREFIX="${{ steps.set_rg_prefix.outputs.resource_group_name_prefix }}"


          # Debugging: Print all variables to ensure they are captured correctly
          echo "::debug::LOCATION: $LOCATION"
          echo "::debug::RESOURCE_GROUP_NAME: $RESOURCE_GROUP_NAME"
          echo "::debug::RESOURCE_GROUP_NAME_PREFIX: $RESOURCE_GROUP_NAME_PREFIX"
          echo "::debug::LOG_ANALYTICS_WORKSPACE_ID: $LOG_ANALYTICS_WORKSPACE_ID"
          echo "::debug::ACR_LOGIN_SERVER: $ACR_LOGIN_SERVER"
          echo "::debug::SERVICEBUS_NAMESPACE_NAME: $SERVICEBUS_NAMESPACE_NAME"
          echo "::debug::SERVICEBUS_CONNECTION_STRING: ${SERVICEBUS_CONNECTION_STRING:0:20}..." # Truncate sensitive data
          echo "::debug::COSMOSDB_MONGODB_CONNECTION_STRING: ${COSMOSDB_MONGODB_CONNECTION_STRING:0:20}..."
          echo "::debug::COSMOSDB_WORKFLOW_CONNECTION_STRING: ${COSMOSDB_WORKFLOW_CONNECTION_STRING:0:20}..."
          echo "::debug::REDIS_CONNECTION_STRING: ${REDIS_CONNECTION_STRING:0:20}..."
          echo "::debug::APPLICATION_INSIGHTS_CONNECTION_STRING: ${APPLICATION_INSIGHTS_CONNECTION_STRING:0:20}..."
          echo "::debug::KEY_VAULT_URI: $KEY_VAULT_URI"
          echo "::debug::KEY_VAULT_ID: $KEY_VAULT_ID"
          echo "::debug::INGESTION_IMAGE: $INGESTION_IMAGE"
          echo "::debug::WORKFLOW_IMAGE: $WORKFLOW_IMAGE"
          echo "::debug::PACKAGE_IMAGE: $PACKAGE_IMAGE"
          echo "::debug::DRONE_SCHEDULER_IMAGE: $DRONE_SCHEDULER_IMAGE"
          echo "::debug::DELIVERY_IMAGE: $DELIVERY_IMAGE"


          terraform -chdir=terraform/apps apply -auto-approve \
            -var="location=$LOCATION" \
            -var="resource_group_name=$RESOURCE_GROUP_NAME" \
            -var="resource_group_name_prefix=$RESOURCE_GROUP_NAME_PREFIX" \
            -var="log_analytics_workspace_id=$LOG_ANALYTICS_WORKSPACE_ID" \
            -var="acr_login_server=$ACR_LOGIN_SERVER" \
            -var="servicebus_namespace_name=$SERVICEBUS_NAMESPACE_NAME" \
            -var="servicebus_connection_string=$SERVICEBUS_CONNECTION_STRING" \
            -var="cosmosdb_mongodb_connection_string=$COSMOSDB_MONGODB_CONNECTION_STRING" \
            -var="cosmosdb_workflow_connection_string=$COSMOSDB_WORKFLOW_CONNECTION_STRING" \
            -var="redis_connection_string=$REDIS_CONNECTION_STRING" \
            -var="application_insights_connection_string=$APPLICATION_INSIGHTS_CONNECTION_STRING" \
            -var="key_vault_uri=$KEY_VAULT_URI" \
            -var="key_vault_id=$KEY_VAULT_ID" \
            -var="ingestion_image=$INGESTION_IMAGE" \
            -var="workflow_image=$WORKFLOW_IMAGE" \
            -var="package_image=$PACKAGE_IMAGE" \
            -var="drone_scheduler_image=$DRONE_SCHEDULER_IMAGE" \
            -var="delivery_image=$DELIVERY_IMAGE"

      - name: Get Ingestion App FQDN
        run: |
          set -euo pipefail # Kept for robustness
          INGESTION_FQDN=$(terraform -chdir=terraform/apps output -raw ingestion_fqdn)
          echo "Ingestion App FQDN: $INGESTION_FQDN"