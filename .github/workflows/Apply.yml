# .github/workflows/Apply.yml
name: Terraform Provision & Deploy Container Apps

on:
  push:
    branches: [main]

permissions:
  contents: read
  id-token: write # Required for Azure Login with OIDC

jobs:
  provision-infra:
    name: Provision Core Infrastructure
    runs-on: ubuntu-latest

    outputs:
      acr_login_server: ${{ steps.acr_output.outputs.acr_login_server }}
      log_analytics_workspace_id: ${{ steps.logs_output.outputs.log_analytics_workspace_id }}
      resource_group_name: ${{ steps.rg_output.outputs.resource_group_name }}
      location: ${{ steps.location_output.outputs.location }}
      servicebus_namespace_name: ${{ steps.servicebus_output.outputs.servicebus_namespace_name }}
      servicebus_connection_string: ${{ steps.servicebus_output.outputs.servicebus_connection_string }}
      cosmosdb_mongodb_connection_string: ${{ steps.cosmosdb_mongodb_output.outputs.cosmosdb_mongodb_connection_string }}
      cosmosdb_workflow_connection_string: ${{ steps.cosmosdb_workflow_output.outputs.cosmosdb_workflow_connection_string }}
      redis_connection_string: ${{ steps.redis_output.outputs.redis_connection_string }}
      application_insights_connection_string: ${{ steps.appinsights_output.outputs.application_insights_connection_string }}
      key_vault_uri: ${{ steps.keyvault_output.outputs.key_vault_uri }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init (Infra)
        run: terraform -chdir=terraform/infra init

      - name: Terraform Apply (Infra)
        run: terraform -chdir=terraform/infra apply -auto-approve

      # --- Output Retrieval Steps for Infra ---
      - name: Get ACR Login Server
        id: acr_output
        run: |
          set -euo pipefail
          FULL_COMMAND_OUTPUT=$(terraform -chdir=terraform/infra output -raw acr_login_server 2>&1)
          echo "::debug::FULL_COMMAND_OUTPUT captured: '$FULL_COMMAND_OUTPUT'"
          ACR_NAME=$(echo "$FULL_COMMAND_OUTPUT" | grep -oE '[a-zA-Z0-9.-]+\.azurecr\.io' | head -n 1)
          echo "::debug::ACR_NAME extracted after regex: '$ACR_NAME'"
          printf "acr_login_server=%s\n" "$ACR_NAME" >> "$GITHUB_OUTPUT"
          echo "::debug::Content written to GITHUB_OUTPUT file:"
          cat "$GITHUB_OUTPUT"

      - name: Debug ACR Login Server
        run: echo "::notice::ACR is ${{ steps.acr_output.outputs.acr_login_server }}"

      - name: Get Log Analytics Workspace ID
        id: logs_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Log Analytics Workspace ID
          RAW_LOG_ID_OUTPUT=$(terraform -chdir=terraform/infra output -raw log_analytics_workspace_id 2>&1)
          echo "::debug::Raw Log Analytics Workspace ID Output: '$RAW_LOG_ID_OUTPUT'"
          LOG_ID=$(echo "$RAW_LOG_ID_OUTPUT" | grep -oE '[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}' | head -n 1)
          echo "::debug::Extracted Log Analytics Workspace ID: '$LOG_ID'"
          printf "log_analytics_workspace_id=%s\n" "$LOG_ID" >> "$GITHUB_OUTPUT"

      - name: Get Resource Group Name
        id: rg_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Resource Group Name
          RAW_RG_NAME_OUTPUT=$(terraform -chdir=terraform/infra output -raw resource_group_name 2>&1)
          echo "::debug::Raw Resource Group Name Output: '$RAW_RG_NAME_OUTPUT'"
          RG_NAME=$(echo "$RAW_RG_NAME_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Resource Group Name: '$RG_NAME'"
          printf "resource_group_name=%s\n" "$RG_NAME" >> "$GITHUB_OUTPUT"

      - name: Get Location
        id: location_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Location
          RAW_LOCATION_OUTPUT=$(terraform -chdir=terraform/infra output -raw location 2>&1)
          echo "::debug::Raw Location Output: '$RAW_LOCATION_OUTPUT'"
          LOCATION=$(echo "$RAW_LOCATION_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Location: '$LOCATION'"
          printf "location=%s\n" "$LOCATION" >> "$GITHUB_OUTPUT"

      - name: Get Service Bus Namespace Name & Connection String
        id: servicebus_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for namespace name
          RAW_NAMESPACE_OUTPUT=$(terraform -chdir=terraform/infra output -raw servicebus_namespace_name 2>&1)
          echo "::debug::Raw Service Bus Namespace Name Output: '$RAW_NAMESPACE_OUTPUT'"
          NAMESPACE_NAME=$(echo "$RAW_NAMESPACE_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Service Bus Namespace Name: '$NAMESPACE_NAME'"

          # Debugging: Print the raw output for connection string
          RAW_CONNECTION_STRING_OUTPUT=$(terraform -chdir=terraform/infra output -raw servicebus_connection_string 2>&1)
          echo "::debug::Raw Service Bus Connection String Output: '$RAW_CONNECTION_STRING_OUTPUT'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING_OUTPUT" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Service Bus Connection String: '$CONNECTION_STRING'"

          printf "servicebus_namespace_name=%s\n" "$NAMESPACE_NAME" >> "$GITHUB_OUTPUT"
          printf "servicebus_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Cosmos DB MongoDB Connection String
        id: cosmosdb_mongodb_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for MongoDB connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw cosmosdb_mongodb_connection_string 2>&1)
          echo "::debug::Raw Cosmos DB MongoDB Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Cosmos DB MongoDB Connection String: '$CONNECTION_STRING'"
          printf "cosmosdb_mongodb_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Cosmos DB Workflow Connection String
        id: cosmosdb_workflow_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Workflow connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw cosmosdb_workflow_connection_string 2>&1)
          echo "::debug::Raw Cosmos DB Workflow Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Cosmos DB Workflow Connection String: '$CONNECTION_STRING'"
          printf "cosmosdb_workflow_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Redis Cache Connection String
        id: redis_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Redis connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw redis_connection_string 2>&1)
          echo "::debug::Raw Redis Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Redis Connection String: '$CONNECTION_STRING'"
          printf "redis_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Application Insights Connection String
        id: appinsights_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Application Insights connection string
          RAW_CONNECTION_STRING=$(terraform -chdir=terraform/infra output -raw application_insights_connection_string 2>&1)
          echo "::debug::Raw Application Insights Connection String Output: '$RAW_CONNECTION_STRING'"
          CONNECTION_STRING=$(echo "$RAW_CONNECTION_STRING" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Application Insights Connection String: '$CONNECTION_STRING'"
          printf "application_insights_connection_string=%s\n" "$CONNECTION_STRING" >> "$GITHUB_OUTPUT"

      - name: Get Key Vault URI
        id: keyvault_output
        run: |
          set -euo pipefail
          # Debugging: Print the raw output for Key Vault URI
          RAW_KEY_VAULT_URI=$(terraform -chdir=terraform/infra output -raw key_vault_uri 2>&1)
          echo "::debug::Raw Key Vault URI Output: '$RAW_KEY_VAULT_URI'"
          KEY_VAULT_URI=$(echo "$RAW_KEY_VAULT_URI" | head -n 1 | tr -d '\r')
          echo "::debug::Extracted Key Vault URI: '$KEY_VAULT_URI'"
          printf "key_vault_uri=%s\n" "$KEY_VAULT_URI" >> "$GITHUB_OUTPUT"
      # --- End Output Retrieval Steps ---

      - name: Debug Provisioning Outputs
        run: |
          echo "::notice::ACR Login Server: ${{ steps.acr_output.outputs.acr_login_server }}"
          echo "::notice::Log Analytics Workspace ID: ${{ steps.logs_output.outputs.log_analytics_workspace_id }}"
          echo "::notice::Resource Group Name: ${{ steps.rg_output.outputs.resource_group_name }}"
          echo "::notice::Location: ${{ steps.location_output.outputs.location }}"
          echo "::notice::Service Bus Namespace Name: ${{ steps.servicebus_output.outputs.servicebus_namespace_name }}"
          echo "::notice::Service Bus Connection String: ${{ steps.servicebus_output.outputs.servicebus_connection_string }}"
          echo "::notice::Cosmos DB MongoDB Connection String: ${{ steps.cosmosdb_mongodb_output.outputs.cosmosdb_mongodb_connection_string }}"
          echo "::notice::Cosmos DB Workflow Connection String: ${{ steps.cosmosdb_workflow_output.outputs.cosmosdb_workflow_connection_string }}"
          echo "::notice::Redis Connection String: ${{ steps.redis_output.outputs.redis_connection_string }}"
          echo "::notice::Application Insights Connection String: ${{ steps.appinsights_output.outputs.application_insights_connection_string }}"
          echo "::notice::Key Vault URI: ${{ steps.keyvault_output.outputs.key_vault_uri }}"


  build-and-push-images:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: provision-infra

    outputs:
      ingestion_image: ${{ steps.push_ingestion.outputs.image_name }}
      workflow_image: ${{ steps.push_workflow.outputs.image_name }}
      package_image: ${{ steps.push_package.outputs.image_name }}
      drone_scheduler_image: ${{ steps.push_drone_scheduler.outputs.image_name }}
      delivery_image: ${{ steps.push_delivery.outputs.image_name }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set ACR Variable
        id: set_acr_var
        run: |
          ACR="${{ needs.provision-infra.outputs.acr_login_server }}"
          echo "ACR_LOGIN_SERVER=$ACR" >> "$GITHUB_ENV"

      - name: Docker Login to ACR
        run: |
          set -euxo pipefail
          ACR_NAME=$(echo "$ACR_LOGIN_SERVER" | cut -d. -f1)
          az acr login --name "$ACR_NAME"

      # --- Build & Push Steps for Each Microservice ---
      - name: Build & Push Ingestion Image
        id: push_ingestion
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/ingestion/:"
          ls -R ./sourcecode/ingestion/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially
          
          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/ingestion:latest"
          if [ ! -f "./sourcecode/ingestion/Dockerfile" ]; then
            echo "::error::Dockerfile not found for ingestion at: ./sourcecode/ingestion/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/ingestion/Dockerfile ./sourcecode/ingestion
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Workflow Image
        id: push_workflow
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/workflow/:"
          ls -R ./sourcecode/workflow/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially
          
          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/workflow:latest"
          if [ ! -f "./sourcecode/workflow/Dockerfile" ]; then
            echo "::error::Dockerfile not found for workflow at: ./sourcecode/workflow/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/workflow/Dockerfile ./sourcecode/workflow
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Package Image
        id: push_package
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/package/:"
          ls -R ./sourcecode/package/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially
          
          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/package:latest"
          if [ ! -f "./sourcecode/package/Dockerfile" ]; then
            echo "::error::Dockerfile not found for package at: ./sourcecode/package/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/package/Dockerfile ./sourcecode/package
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Drone Scheduler Image
        id: push_drone_scheduler
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/drone-scheduler/:"
          ls -R ./sourcecode/drone-scheduler/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially
          
          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/drone-scheduler:latest"
          if [ ! -f "./sourcecode/drone-scheduler/Dockerfile" ]; then
            echo "::error::Dockerfile not found for drone-scheduler at: ./sourcecode/drone-scheduler/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/drone-scheduler/Dockerfile ./sourcecode/drone-scheduler
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Build & Push Delivery Image
        id: push_delivery
        run: |
          set -euo pipefail
          # Debugging: List contents of sourcecode directory to verify Dockerfile path
          echo "::debug::Listing contents of ./sourcecode/delivery/:"
          ls -R ./sourcecode/delivery/ || true # Use || true to prevent step failure if directory is empty or path is wrong initially
          
          IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/delivery:latest"
          if [ ! -f "./sourcecode/delivery/Dockerfile" ]; then
            echo "::error::Dockerfile not found for delivery at: ./sourcecode/delivery/Dockerfile. Please check your repository structure."
            exit 1
          fi
          docker build -t "$IMAGE_NAME" -f ./sourcecode/delivery/Dockerfile ./sourcecode/delivery
          docker push "$IMAGE_NAME"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
      # --- End Build & Push Steps ---

  deploy-apps:
    name: Deploy Container Apps
    runs-on: ubuntu-latest
    needs: [provision-infra, build-and-push-images]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init & Apply (Apps)
        run: |
          set -euxo pipefail
          # Correctly assign RG_NAME and RG_NAME_PREFIX from job outputs
          # These variables should directly reference the outputs from the previous job
          RG_NAME="${{ needs.provision-infra.outputs.resource_group_name }}"
          RG_NAME_PREFIX=$(echo "$RG_NAME" | sed -E 's/^aca-rg-//')
          
          # Debugging: Print all variables before Terraform Apply
          echo "::debug::Applying Terraform with the following variables:"
          echo "::debug::acr_login_server: ${{ needs.provision-infra.outputs.acr_login_server }}"
          echo "::debug::log_analytics_workspace_id: ${{ needs.provision-infra.outputs.log_analytics_workspace_id }}"
          echo "::debug::resource_group_name: ${{ needs.provision-infra.outputs.resource_group_name }}"
          echo "::debug::location: ${{ needs.provision-infra.outputs.location }}"
          echo "::debug::resource_group_name_prefix: $RG_NAME_PREFIX"
          echo "::debug::servicebus_namespace_name: ${{ needs.provision-infra.outputs.servicebus_namespace_name }}"
          echo "::debug::servicebus_connection_string: ${{ needs.provision-infra.outputs.servicebus_connection_string }}"
          echo "::debug::cosmosdb_mongodb_connection_string: ${{ needs.provision-infra.outputs.cosmosdb_mongodb_connection_string }}"
          echo "::debug::cosmosdb_workflow_connection_string: ${{ needs.cosmosdb_workflow_output.outputs.cosmosdb_workflow_connection_string }}"
          echo "::debug::redis_connection_string: ${{ needs.redis_output.outputs.redis_connection_string }}"
          echo "::debug::application_insights_connection_string: ${{ needs.appinsights_output.outputs.application_insights_connection_string }}"
          echo "::debug::key_vault_uri: ${{ needs.keyvault_output.outputs.key_vault_uri }}"
          echo "::debug::ingestion_image: ${{ needs.build-and-push-images.outputs.ingestion_image }}"
          echo "::debug::workflow_image: ${{ needs.build-and-push-images.outputs.workflow_image }}"
          echo "::debug::package_image: ${{ needs.build-and-push-images.outputs.package_image }}"
          echo "::debug::drone_scheduler_image: ${{ needs.build-and-push-images.outputs.drone_scheduler_image }}"
          echo "::debug::delivery_image: ${{ needs.build-and-push-images.outputs.delivery_image }}"

          terraform -chdir=terraform/apps init
          terraform -chdir=terraform/apps apply -auto-approve \
            -var="acr_login_server=${{ needs.provision-infra.outputs.acr_login_server }}" \
            -var="log_analytics_workspace_id=${{ needs.provision-infra.outputs.log_analytics_workspace_id }}" \
            -var="resource_group_name=${{ needs.provision-infra.outputs.resource_group_name }}" \
            -var="location=${{ needs.provision-infra.outputs.location }}" \
            -var="resource_group_name_prefix=$RG_NAME_PREFIX" \
            -var="servicebus_namespace_name=${{ needs.provision-infra.outputs.servicebus_namespace_name }}" \
            -var="servicebus_connection_string=${{ needs.provision-infra.outputs.servicebus_connection_string }}" \
            -var="cosmosdb_mongodb_connection_string=${{ needs.provision-infra.outputs.cosmosdb_mongodb_connection_string }}" \
            -var="cosmosdb_workflow_connection_string=${{ needs.cosmosdb_workflow_output.outputs.cosmosdb_workflow_connection_string }}" \
            -var="redis_connection_string=${{ needs.redis_output.outputs.redis_connection_string }}" \
            -var="application_insights_connection_string=${{ needs.appinsights_output.outputs.application_insights_connection_string }}" \
            -var="key_vault_uri=${{ needs.keyvault_output.outputs.key_vault_uri }}" \
            -var="ingestion_image=${{ needs.build-and-push-images.outputs.ingestion_image }}" \
            -var="workflow_image=${{ needs.build-and-push-images.outputs.workflow_image }}" \
            -var="package_image=${{ needs.build-and-push-images.outputs.package_image }}" \
            -var="drone_scheduler_image=${{ needs.build-and-push-images.outputs.drone_scheduler_image }}" \
            -var="delivery_image=${{ needs.build-and-push-images.outputs.delivery_image }}"

      - name: Get Ingestion App FQDN
        run: |
          set -euo pipefail
          # Assuming you'll have an output named 'ingestion_fqdn' in terraform/apps
          INGESTION_FQDN=$(terraform -chdir=terraform/apps output -raw ingestion_fqdn 2>&1)
          echo "::notice::Ingestion Container App URL: $INGESTION_FQDN"
